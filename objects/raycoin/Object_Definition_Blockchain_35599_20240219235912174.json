{"enableComments":false,"objectRelationships":[{"objectDefinitionSystem2":false,"objectField":{"relationshipType":"oneToMany","indexed":true,"localized":false,"objectFieldSettings":[{"name":"objectDefinition1ShortName","value":"Blockchain"},{"name":"objectRelationshipERCObjectFieldName","value":"r_blockchain_c_blockchainERC"}],"readOnly":"false","DBType":"Long","label":{"en_US":"Blockchain"},"type":"Long","required":true,"externalReferenceCode":"8b30e1ab-5435-6a10-5e13-ecd4e3b7f61e","indexedAsKeyword":false,"system":false,"indexedLanguageId":"","unique":false,"name":"r_blockchain_c_blockchainId","state":false,"businessType":"Relationship","readOnlyConditionExpression":""},"parameterObjectFieldName":"","parameterObjectFieldId":0,"label":{"en_US":"Blockchain"},"reverse":false,"type":"oneToMany","externalReferenceCode":"e8d36d02-e797-1270-8ca8-ab3cbdc18da7","objectDefinitionModifiable2":true,"system":false,"name":"blockchain","deletionType":"prevent","objectDefinitionExternalReferenceCode1":"5ed305b5-aa77-ce2d-4df0-c8e9966c4d1b","objectDefinitionExternalReferenceCode2":"348b6c11-87a6-5dcb-4ece-998b71cdb5ab","objectDefinitionName2":"Block"}],"enableCategorization":false,"accountEntryRestrictedObjectFieldName":"","objectActions":[{"conditionExpression":"","objectActionExecutorKey":"groovy","errorMessage":{"en_US":"Unable to Mine Pending Transactions"},"active":true,"description":"","label":{"en_US":"Mine Pending Transactions"},"externalReferenceCode":"c5d91a9e-9bf2-53a1-e050-22aeea12a0cc","system":false,"objectActionTriggerKey":"standalone","name":"minePendingTransactions","parameters":{"script":"package com.liferay.raycoin.objects.blockchain\n\nimport java.security.MessageDigest\n\nimport javax.json.Json\nimport javax.json.JsonArray\nimport javax.json.JsonArrayBuilder\nimport javax.json.JsonBuilderFactory\nimport javax.json.JsonObject\n\nimport org.apache.http.HttpResponse\nimport org.apache.http.HttpStatus\nimport org.apache.http.client.HttpClient\nimport org.apache.http.client.methods.HttpGet\nimport org.apache.http.client.methods.HttpPut\nimport org.apache.http.impl.client.HttpClientBuilder\nimport org.apache.http.util.EntityUtils\n\nimport com.liferay.object.model.ObjectEntry\nimport com.liferay.object.service.ObjectDefinitionLocalServiceUtil\nimport com.liferay.object.service.ObjectEntryLocalServiceUtil\nimport com.liferay.portal.kernel.dao.orm.QueryUtil\nimport com.liferay.portal.kernel.service.ServiceContext\nimport com.liferay.portal.kernel.service.UserLocalServiceUtil\nimport com.liferay.portal.kernel.workflow.WorkflowConstants\n\ndef userId = Long.valueOf(creator)\ndef user = UserLocalServiceUtil.getUserById(userId)\n\ndef objDef = ObjectDefinitionLocalServiceUtil.fetchObjectDefinition(user.companyId, \"C_Transaction\")\nList<ObjectEntry> pendingTransactions = ObjectEntryLocalServiceUtil.getObjectEntries(\n\t\t0, objDef.objectDefinitionId, WorkflowConstants.STATUS_PENDING, QueryUtil.ALL_POS, QueryUtil.ALL_POS)\n\nif(pendingTransactions.size() > maxPendingTransactions) {\n\tdef blockchain = new Blockchain(\n\t\t\tuser.companyId, userId, id, rewardAddress, rewardValue, pendingTransactions, authorization, blockchainURL)\n\tblockchain.minePendingTransactions()\n}\n\nclass Blockchain {\n\n\tlong companyId\n\tlong userId\n\tlong blockchainId\n\tString rewardAddress\n\tBigDecimal rewardValue\n\tList<ObjectEntry> pendingTransactions\n\tString authorization\n\tString blockchainURL\n\n\tBlockchain(companyId, userId, blockchainId, rewardAddress, rewardValue, pendingTransactions, authorization, blockchainURL) {\n\t\tthis.companyId = companyId\n\t\tthis.userId = userId\n\t\tthis.blockchainId = blockchainId\n\t\tthis.rewardAddress = rewardAddress\n\t\tthis.rewardValue = rewardValue\n\t\tthis.pendingTransactions = pendingTransactions\n\t\tthis.authorization = authorization\n\t\tthis.blockchainURL = blockchainURL\n\t}\n\n\tvoid minePendingTransactions() {\n\n\t\tif(pendingTransactions == null || pendingTransactions.size() <= 0) {\n\t\t\tprintln \"There is no transactions to process\"\n\t\t\treturn\n\t\t}\n\n\t\tList<Transaction> transactions = new ArrayList<Transaction>()\n\n\t\t// Get all pending transactions and put it on an internal list\n\t\tpendingTransactions.each { pt ->\n\t\t\t// get the transaction only if the signature is valid\n\t\t\tif(pt.getValues().get(\"signatureValid\") == true) {\n\t\t\t\ttransactions << new Transaction(\n\t\t\t\t\t\tpt.getValues().get(\"fromAddress\"),\n\t\t\t\t\t\tpt.getValues().get(\"toAddress\"),\n\t\t\t\t\t\tpt.getValues().get(\"amount\"),\n\t\t\t\t\t\tpt.getValues().get(\"signature\"),\n\t\t\t\t\t\tpt.objectEntryId)\n\t\t\t}\n\t\t}\n\n\t\t// Create reward transaction and add to transactions list\n\t\tdef rewardTransaction = new Transaction(\"none\", rewardAddress, rewardValue)\n\t\trewardTransaction.save(companyId, userId)\n\t\ttransactions << rewardTransaction\n\n\t\t// get the hash and index from the latest block on the chain\n\t\tJsonObject latestBlockJson = this.latestBlockJson.getJsonObject(0)\n\t\tdef index = latestBlockJson.getJsonNumber(\"index\").intValue()+1\n\t\tdef previousHash = latestBlockJson.getString(\"hash\")\n\n\t\t// update the status of all transactions to scheduled, so it will avoid processing from another thread\n\t\ttransactions.each { t ->\n\t\t\tt.updateStatus(userId, WorkflowConstants.STATUS_SCHEDULED)\n\t\t}\n\n\t\t// creates the block objects and mine based on all information and using the difficulty level\n\t\tdef block = new Block(index, new Date().toString(), transactions, previousHash, blockchainId)\n\t\tdef difficulty = 2\n\t\tblock.mineBlock(difficulty)\n\n\t\t// check if there is another block with the same previousHash,\n\t\t// if true, there is already another block mined and then we should give up this block\n\t\tdef blockWithPreviousHashJson = this.getBlockWithPreviousHashJson(previousHash)\n\t\tif(blockWithPreviousHashJson != null && blockWithPreviousHashJson.size() > 0) {\n\n\t\t\t// we have to remove the reward transaction too\n\t\t\trewardTransaction.delete()\n\n\t\t\t// go back all the transactions to pending as the block won't be saved\n\t\t\ttransactions.each { t ->\n\t\t\t\tt.updateStatus(userId, WorkflowConstants.STATUS_PENDING)\n\t\t\t}\n\n\t\t\t// stop the execution\n\t\t\treturn\n\t\t}\n\n\t\t// persist the block\n\t\tObjectEntry blockMined = block.save(companyId, userId)\n\n\t\t// get the balances of all transactions and put in a hash map to validate balances\n\t\tMap<String, BigDecimal> walletBalances = new HashMap<String, BigDecimal>()\n\t\ttransactions.each { t ->\n\t\t\twalletBalances.put(t.fromAddress, this.getWalletBalance(t.fromAddress))\n\t\t}\n\n\t\twalletBalances.each { b ->\n\t\t\tprintln b.key + \" - \" + b.value\n\t\t}\n\n\t\t// process all scheduled transactions\n\t\ttransactions.each { t ->\n\n\t\t\t// add the transaction to block\n\t\t\tt.addToBlock(userId, blockMined.objectEntryId)\n\n\t\t\t// check if the addressFrom has balance to debt the value\n\t\t\tBigDecimal balance = walletBalances.get(t.fromAddress)\n\t\t\tif(balance < t.amount) {\n\t\t\t\tprintln \"Wallet $t.fromAddress doesn't have sufficient coins\"\n\t\t\t\tt.updateStatus(userId, WorkflowConstants.STATUS_DENIED)\n\t\t\t} else {\n\t\t\t\twalletBalances.put(t.fromAddress, balance - t.amount)\n\t\t\t\tt.updateStatus(userId, WorkflowConstants.STATUS_APPROVED)\n\t\t\t}\n\n\t\t\t// also, if a address is receiving coins in the same block, credit this value to it balance\n\t\t\tif(walletBalances.containsKey(t.toAddress)) {\n\t\t\t\twalletBalances.put(t.toAddress, (walletBalances.get(t.toAddress)+t.amount))\n\t\t\t}\n\t\t}\n\n\t\tdef computeBalanceUrl = \"${blockchainURL}/o/c/blockchains/${blockchainId}/object-actions/computeBalances\"\n\n\t\tThread.start {\n\t\t\tsleep(3000)\n\n\t\t\t// add the reward transaction to this block\n\t\t\trewardTransaction.updateStatus(userId, WorkflowConstants.STATUS_APPROVED)\n\t\t\trewardTransaction.addToBlock(userId, blockMined.objectEntryId)\n\n\t\t\t// also compute the balances\n\t\t\tHttpClient httpClient = HttpClientBuilder.create().build()\n\t\t\tHttpPut httpPut = new HttpPut(computeBalanceUrl)\n\n\t\t\thttpPut.setHeader('Content-Type', 'application/json')\n\t\t\thttpPut.setHeader('Authorization', \"$authorization\")\n\n\t\t\tHttpResponse putResponse = httpClient.execute(httpPut)\n\t\t\tint putResponseStatus = putResponse.getStatusLine().getStatusCode()\n\n\t\t\tprintln \"PUT response status: ${putResponse.getStatusLine()}\"\n\n\t\t\tif (putResponseStatus == HttpStatus.SC_OK || putResponseStatus == HttpStatus.SC_NO_CONTENT) {\n\t\t\t\tprintln \"Successfully PUT to computeBalances.\"\n\t\t\t} else {\n\t\t\t\tprintln \"Error in PUT minePendingTransactions. Error code: $putResponseStatus\"\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate BigDecimal getWalletBalance(String address) {\n\n\t\tdef encodedFilter = URLEncoder.encode(\"address eq '${address}'\", \"UTF-8\")\n\t\tdef getUrl = \"${this.blockchainURL}/o/c/walletbalances/?filter=${encodedFilter}\"\n\n\t\tJsonArray walletBalancesJsonArray = this.fetchItemsFromApi(getUrl, authorization)\n\t\tif(walletBalancesJsonArray.empty) {\n\t\t\treturn new BigDecimal(0)\n\t\t} else {\n\t\t\tJsonObject walletBalance = walletBalancesJsonArray.getJsonObject(0)\n\t\t\treturn new BigDecimal(walletBalance.getJsonNumber(\"balance\").toString())\n\t\t}\n\t}\n\n\tprivate JsonArray getLatestBlockJson() {\n\n\t\tdef encodedSort = URLEncoder.encode(\"id:desc\", \"UTF-8\")\n\t\tdef getUrl = \"${this.blockchainURL}/o/c/blocks/?sort=${encodedSort}&pageSize=1\"\n\n\t\treturn this.fetchItemsFromApi(getUrl)\n\t}\n\n\tprivate JsonArray getBlockWithPreviousHashJson(String previousHash) {\n\n\t\tdef encodedFilter = URLEncoder.encode(\"previousHash eq '${previousHash}'\", \"UTF-8\")\n\t\tdef getUrl = \"${this.blockchainURL}/o/c/blocks/?filter=${encodedFilter}\"\n\n\t\treturn this.fetchItemsFromApi(getUrl)\n\t}\n\n\tprivate JsonArray fetchItemsFromApi(url, authheader = null) {\n\t\tHttpGet httpGet = new HttpGet(url)\n\t\thttpGet.setHeader('Content-Type', 'application/json')\n\t\tif(authheader != null) {\n\t\t\thttpGet.setHeader('Authorization', \"$authheader\")\n\t\t}\n\n\t\tHttpClient httpClient = HttpClientBuilder.create().build()\n\t\tHttpResponse getResponse = httpClient.execute(httpGet)\n\t\tString getResponseBody = EntityUtils.toString(getResponse.getEntity())\n\t\tJsonObject getResponseJson = Json.createReader(new StringReader(getResponseBody)).readObject()\n\t\treturn getResponseJson.getJsonArray(\"items\")\n\t}\n}\n\nclass Block {\n\n\tlong blockchainId\n\tint index\n\tString timestamp\n\tList<Transaction> transactions\n\tString previousHash\n\tString hash\n\tint nonce\n\n\tBlock(int index, String timestamp, List<Transaction> transactions, String previousHash, long blockchainId) {\n\t\tthis.index = index\n\t\tthis.timestamp = timestamp\n\t\tthis.transactions = transactions\n\t\tthis.previousHash = previousHash\n\t\tthis.nonce = 0\n\t\tthis.hash = calculateHash()\n\t\tthis.blockchainId = blockchainId\n\t}\n\n\tString calculateHash() {\n\t\treturn md5(\"${index}${timestamp}${Transaction.toJsonArray(transactions)}${previousHash}${nonce}\")\n\t}\n\n\tvoid mineBlock(int difficulty) {\n\t\twhile (!hash[0..<difficulty].every { it == '0' }) {\n\t\t\tnonce++\n\t\t\thash = calculateHash()\n\t\t}\n\t\tprintln \"Block mined: ${hash}\"\n\t}\n\n\tString md5(String input) {\n\t\tMessageDigest digest = MessageDigest.getInstance(\"MD5\")\n\t\tbyte[] hash = digest.digest(input.getBytes(\"UTF-8\"))\n\t\treturn hash.encodeHex().toString()\n\t}\n\n\tObjectEntry save(long companyId, long userId) {\n\t\tdef values = [index: index, hash: hash, previousHash: previousHash, nonce: nonce, r_blockchain_c_blockchainId: blockchainId]\n\t\tdef objDef = ObjectDefinitionLocalServiceUtil.fetchObjectDefinition(companyId, \"C_Block\")\n\t\treturn ObjectEntryLocalServiceUtil.addObjectEntry(\n\t\t\t\tuserId, 0, objDef.objectDefinitionId, values, new ServiceContext())\n\t}\n}\n\nclass Transaction {\n\n\tLong id\n\tString fromAddress\n\tString toAddress\n\tBigDecimal amount\n\tString signature\n\n\tTransaction(String fromAddress, String toAddress, BigDecimal amount, String signature = \"0\", Long id = 0) {\n\t\tthis.fromAddress = fromAddress\n\t\tthis.toAddress = toAddress\n\t\tthis.amount = amount\n\t\tthis.signature = signature\n\t\tthis.id = id\n\t}\n\n\tString getTransactionData() {\n\t\treturn \"${fromAddress}${toAddress}${amount}\"\n\t}\n\n\tJsonObject toJson() {\n\t\tJsonBuilderFactory factory = Json.createBuilderFactory(null);\n\t\tJsonObject transactionJson = factory.createObjectBuilder()\n\t\t\t\t.add(\"fromAddress\", fromAddress)\n\t\t\t\t.add(\"toAddress\", toAddress)\n\t\t\t\t.add(\"amount\", amount)\n\t\t\t\t.add(\"signature\", signature)\n\t\t\t\t.add(\"id\", id)\n\t\t\t\t.build();\n\t\treturn transactionJson;\n\t}\n\n\tstatic JsonArray toJsonArray(List<Transaction> transactions) {\n\t\tJsonBuilderFactory factory = Json.createBuilderFactory(null);\n\t\tJsonArrayBuilder arrayBuilder = factory.createArrayBuilder();\n\t\tfor (Transaction transaction : transactions) {\n\t\t\tarrayBuilder.add(transaction.toJson());\n\t\t}\n\t\treturn arrayBuilder.build();\n\t}\n\n\tString toString() {\n\t\treturn toJson().toString();\n\t}\n\n\tObjectEntry save(long companyId, long userId) {\n\t\tdef values = [fromAddress: fromAddress, toAddress: toAddress, amount: amount, signature: signature]\n\t\tdef objDef = ObjectDefinitionLocalServiceUtil.fetchObjectDefinition(companyId, \"C_Transaction\")\n\t\tObjectEntry obj = ObjectEntryLocalServiceUtil.addObjectEntry(\n\t\t\t\tuserId, 0, objDef.objectDefinitionId, values, new ServiceContext())\n\t\tthis.id = obj.objectEntryId\n\t\treturn obj\n\t}\n\n\tObjectEntry updateStatus(long userId, int status) {\n\t\treturn ObjectEntryLocalServiceUtil.updateStatus(userId, this.id, status, new ServiceContext())\n\t}\n\n\tObjectEntry addToBlock(long userId, long blockId) {\n\t\tdef values = [r_transactions_c_blockId: blockId]\n\t\treturn ObjectEntryLocalServiceUtil.updateObjectEntry(userId, this.id, values, new ServiceContext())\n\t}\n\n\tvoid delete() {\n\t\tObjectEntryLocalServiceUtil.deleteObjectEntry(this.id)\n\t}\n}\n"},"status":{"label_i18n":"Success","code":1,"label":"success"}},{"conditionExpression":"","objectActionExecutorKey":"groovy","errorMessage":{"en_US":"Error computing balance"},"active":true,"description":"","label":{"en_US":"Compute Balances"},"externalReferenceCode":"77cdeb97-e021-d970-cb4a-29ff531b7bb7","system":false,"objectActionTriggerKey":"standalone","name":"computeBalances","parameters":{"script":"package com.liferay.raycoin.objects.blockchain\n\nimport com.liferay.object.model.ObjectEntry\nimport com.liferay.object.service.ObjectDefinitionLocalServiceUtil\nimport com.liferay.object.service.ObjectEntryLocalServiceUtil\nimport com.liferay.portal.kernel.dao.orm.QueryUtil\nimport com.liferay.portal.kernel.service.ServiceContext\nimport com.liferay.portal.kernel.workflow.WorkflowConstants\n\ndef obj = ObjectEntryLocalServiceUtil.getObjectEntry(id)\nbalance = new BlockchainBalance(obj.getCompanyId(), Long.valueOf(creator))\nbalance.computeBalance()\n\nclass BlockchainBalance {\n\n\tlong companyId\n\tlong userId\n\tlong objectDefinitionId\n\n\tBlockchainBalance(long companyId, long userId) {\n\t\tthis.companyId = companyId\n\t\tthis.userId = userId\n\t\tthis.objectDefinitionId = ObjectDefinitionLocalServiceUtil.fetchObjectDefinition(\n\t\t\t\tthis.companyId, \"C_WalletBalance\").getObjectDefinitionId()\n\t}\n\n\tvoid computeBalance() {\n\n\t\tremoveAllBalances()\n\n\t\tMap<String, BigDecimal> balances = new HashMap<String, BigDecimal>()\n\n\t\tdef objTransactionDef = ObjectDefinitionLocalServiceUtil.fetchObjectDefinition(\n\t\t\t\tthis.companyId, \"C_Transaction\")\n\t\tList<ObjectEntry> approvedTransactions = ObjectEntryLocalServiceUtil.getObjectEntries(\n\t\t\t\t0, objTransactionDef.objectDefinitionId, WorkflowConstants.STATUS_APPROVED, QueryUtil.ALL_POS, QueryUtil.ALL_POS)\n\n\t\t// fix the balance for 'none' wallet to be able to distribute reward to miners\n\t\tbalances.put(\"none\", 1000000000)\n\n\t\tapprovedTransactions.each { t ->\n\t\t\tdef v = ObjectEntryLocalServiceUtil.getValues(t.objectEntryId)\n\n\t\t\tdef fromAddress = v.get(\"fromAddress\")\n\t\t\tdef toAddress = v.get(\"toAddress\")\n\t\t\tdef amount = v.get(\"amount\")\n\n\t\t\tif(balances.get(fromAddress) == null) {\n\t\t\t\tbalances.put(fromAddress, new BigDecimal(0))\n\t\t\t}\n\n\t\t\tif(balances.get(toAddress) == null) {\n\t\t\t\tbalances.put(toAddress, new BigDecimal(0))\n\t\t\t}\n\n\t\t\tbalances.put(fromAddress, balances.get(fromAddress) - amount)\n\t\t\tbalances.put(toAddress, balances.get(toAddress) + amount)\n\t\t}\n\n\t\tbalances.each { address, balance ->\n\t\t\tdef walletBalanceValues = [address: address, balance: balance]\n\t\t\tObjectEntryLocalServiceUtil.addObjectEntry(\n\t\t\t\t\tuserId, 0, objectDefinitionId, walletBalanceValues, new ServiceContext())\n\t\t}\n\t}\n\n\tvoid removeAllBalances() {\n\t\tdef balanceEntries = ObjectEntryLocalServiceUtil.getObjectEntries(\n\t\t\t\t0, objectDefinitionId, QueryUtil.ALL_POS, QueryUtil.ALL_POS)\n\t\tbalanceEntries.each { b ->\n\t\t\tObjectEntryLocalServiceUtil.deleteObjectEntry(b.objectEntryId)\n\t\t}\n\t}\n}\n"},"status":{"label_i18n":"Success","code":1,"label":"success"}}],"enableLocalization":false,"accountEntryRestricted":false,"externalReferenceCode":"5ed305b5-aa77-ce2d-4df0-c8e9966c4d1b","objectFields":[{"indexed":false,"localized":false,"objectFieldSettings":[],"readOnly":"true","DBType":"String","label":{"en_US":"Author"},"type":"String","required":false,"externalReferenceCode":"4f43acff-3c2e-0c94-8f0f-59877309f0db","indexedAsKeyword":false,"system":true,"indexedLanguageId":"","unique":false,"name":"creator","state":false,"businessType":"Text","readOnlyConditionExpression":""},{"indexed":false,"localized":false,"objectFieldSettings":[],"readOnly":"true","DBType":"Date","label":{"en_US":"Create Date"},"type":"Date","required":false,"externalReferenceCode":"b905b0aa-3722-c97b-b372-fce51969dd5c","indexedAsKeyword":false,"system":true,"indexedLanguageId":"","unique":false,"name":"createDate","state":false,"businessType":"Date","readOnlyConditionExpression":""},{"indexed":false,"localized":false,"objectFieldSettings":[],"readOnly":"false","DBType":"String","label":{"en_US":"External Reference Code"},"type":"String","required":false,"externalReferenceCode":"34abbe53-edcf-5f6f-cc0e-ddf0b0b6debb","indexedAsKeyword":false,"system":true,"indexedLanguageId":"","unique":false,"name":"externalReferenceCode","state":false,"businessType":"Text","readOnlyConditionExpression":""},{"indexed":true,"localized":false,"objectFieldSettings":[],"readOnly":"true","DBType":"Long","label":{"en_US":"ID"},"type":"Long","required":false,"externalReferenceCode":"da708dcd-b836-16d2-1a02-c3839ee1c861","indexedAsKeyword":true,"system":true,"indexedLanguageId":"","unique":false,"name":"id","state":false,"businessType":"LongInteger","readOnlyConditionExpression":""},{"indexed":false,"localized":false,"objectFieldSettings":[],"readOnly":"true","DBType":"Date","label":{"en_US":"Modified Date"},"type":"Date","required":false,"externalReferenceCode":"c2aab21f-c55b-8c9d-c5d6-ef74f0cf92a9","indexedAsKeyword":false,"system":true,"indexedLanguageId":"","unique":false,"name":"modifiedDate","state":false,"businessType":"Date","readOnlyConditionExpression":""},{"indexed":false,"localized":false,"objectFieldSettings":[],"readOnly":"true","DBType":"String","label":{"en_US":"Status"},"type":"String","required":false,"externalReferenceCode":"256210af-1b3a-4ed7-dbb6-3cb50cc33f74","indexedAsKeyword":false,"system":true,"indexedLanguageId":"","unique":false,"name":"status","state":false,"businessType":"Text","readOnlyConditionExpression":""},{"indexed":true,"localized":false,"objectFieldSettings":[],"readOnly":"false","DBType":"String","label":{"en_US":"Name"},"type":"String","required":true,"externalReferenceCode":"5d015d90-09fc-883b-3751-da8499b4167d","indexedAsKeyword":false,"system":false,"indexedLanguageId":"","unique":false,"name":"name","state":false,"businessType":"Text","readOnlyConditionExpression":""},{"indexed":true,"localized":false,"objectFieldSettings":[],"readOnly":"false","DBType":"Integer","label":{"en_US":"Max Pending Transactions"},"type":"Integer","required":true,"externalReferenceCode":"aefd138f-441a-5c20-d697-d12ce51d9512","indexedAsKeyword":false,"system":false,"indexedLanguageId":"","unique":false,"name":"maxPendingTransactions","state":false,"businessType":"Integer","readOnlyConditionExpression":""},{"indexed":true,"localized":false,"objectFieldSettings":[{"name":"showCounter","value":false}],"readOnly":"false","DBType":"Clob","label":{"en_US":"Reward Address"},"type":"Clob","required":true,"externalReferenceCode":"bc6eb3cc-c915-7f85-ce2a-22d83b1d7cec","indexedAsKeyword":false,"system":false,"indexedLanguageId":"","unique":false,"name":"rewardAddress","state":false,"businessType":"LongText","readOnlyConditionExpression":""},{"indexed":true,"localized":false,"objectFieldSettings":[],"readOnly":"false","DBType":"BigDecimal","label":{"en_US":"Reward Value"},"type":"BigDecimal","required":true,"externalReferenceCode":"2fd4df86-a70c-3fa3-9466-00a5ce355624","indexedAsKeyword":false,"system":false,"indexedLanguageId":"","unique":false,"name":"rewardValue","state":false,"businessType":"PrecisionDecimal","readOnlyConditionExpression":""},{"indexed":true,"localized":false,"objectFieldSettings":[{"name":"showCounter","value":false}],"readOnly":"false","DBType":"Clob","label":{"en_US":"Authorization"},"type":"Clob","required":true,"externalReferenceCode":"d0cc6bd0-7f3e-9c1f-a6bb-61815a7659b9","indexedAsKeyword":false,"system":false,"indexedLanguageId":"","unique":false,"name":"authorization","state":false,"businessType":"LongText","readOnlyConditionExpression":""},{"indexed":true,"localized":false,"objectFieldSettings":[],"readOnly":"false","DBType":"String","label":{"en_US":"BlockchainURL"},"type":"String","required":true,"externalReferenceCode":"1dc4d70b-b1ef-73d9-1597-ff170c1203af","indexedAsKeyword":false,"system":false,"indexedLanguageId":"","unique":false,"name":"blockchainURL","state":false,"businessType":"Text","readOnlyConditionExpression":""}],"restContextPath":"/o/c/blockchains","scope":"company","portlet":true,"modifiable":true,"parameterRequired":false,"enableObjectEntryHistory":false,"titleObjectFieldName":"name","objectValidationRules":[],"active":true,"defaultLanguageId":"en_US","label":{"en_US":"Blockchain"},"panelCategoryKey":"applications_menu.applications.custom.apps","pluralLabel":{"en_US":"Blockchains"},"objectLayouts":[],"system":false,"objectViews":[],"name":"Blockchain","actions":{"permissions":{},"get":{},"update":{},"delete":{}},"status":{"label_i18n":"Approved","code":0,"label":"approved"}}